{
  "name": "Coin Change",
  "question": "**Coin Change**\n================\n\n### Problem Description\n\nGiven an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money, return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an unlimited number of each coin.\n\n### Input and Output Format\n\n* **Input:** `coins = [1, 2, 5]`, `amount = 11`\n* **Output:** `3` (because `11 = 5 + 5 + 1`)\n\n### Constraints\n\n* `1 <= coins.length <= 12`\n* `1 <= coins[i] <= 2^31 - 1`\n* `0 <= amount <= 2^31 - 1`\n\n### Examples\n\n#### Example 1\n\n* **Input:** `coins = [1, 2, 5]`, `amount = 11`\n* **Output:** `3`\n* **Explanation:** `11 = 5 + 5 + 1`\n\n#### Example 2\n\n* **Input:** `coins = [2]`, `amount = 3`\n* **Output:** `-1`\n* **Explanation:** It's not possible to make up `3` using only coins of denomination `2`.\n\n#### Example 3\n\n* **Input:** `coins = [1]`, `amount = 0`\n* **Output:** `0`\n* **Explanation:** We don't need any coins to make up `0`.\n\n#### Example 4\n\n* **Input:** `coins = [1]`, `amount = 2`\n* **Output:** `2`\n* **Explanation:** `2 = 1 + 1`\n\n### Function Signature\n\n```python\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n```\n\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        \n    }\n}\n```\n\n```cpp\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        \n    }\n};\n```\n\nYour task is to fill in the implementation of the `coinChange` method to solve the problem.",
  "correct_answer": "**Coin Change Problem Solution**\n================================\n\nThe Coin Change problem is a classic dynamic programming problem. The problem statement is as follows:\n\nGiven an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money, return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\n**Complete Working Code Solution**\n---------------------------------\n\n```python\ndef coinChange(coins, amount):\n    \"\"\"\n    Returns the fewest number of coins that make up the given amount.\n    \n    Args:\n    coins (list): A list of coin denominations.\n    amount (int): The total amount of money.\n    \n    Returns:\n    int: The fewest number of coins that make up the amount. Returns -1 if it's not possible.\n    \"\"\"\n    # Create a table to store the results of subproblems\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # Base case: 0 coins are needed to make up 0 amount\n    \n    # Iterate over each coin denomination\n    for coin in coins:\n        # Iterate over each amount from the coin denomination to the target amount\n        for x in range(coin, amount + 1):\n            # Update the table with the minimum number of coins\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    \n    # Return the result\n    return dp[amount] if dp[amount] != float('inf') else -1\n\n# Example usage\ncoins = [1, 2, 5]\namount = 11\nresult = coinChange(coins, amount)\nprint(f\"The fewest number of coins that make up {amount} is {result}\")\n```\n\n**Algorithm Explanation**\n------------------------\n\nThe algorithm uses dynamic programming to solve the problem. The basic idea is to break down the problem into smaller subproblems and store the results of these subproblems in a table. The table is then used to construct the solution to the original problem.\n\nHere's a step-by-step breakdown of the algorithm:\n\n1.  Create a table `dp` of size `amount + 1`, where `dp[i]` represents the fewest number of coins that make up the amount `i`. Initialize the table with `float('inf')`, which represents an impossible amount.\n2.  Set `dp[0] = 0`, which represents the base case where 0 coins are needed to make up 0 amount.\n3.  Iterate over each coin denomination `coin`.\n4.  For each coin, iterate over each amount `x` from `coin` to `amount`.\n5.  Update the table `dp[x]` with the minimum number of coins between the current value and `dp[x - coin] + 1`. This represents the fewest number of coins that make up the amount `x` by either using the current coin or not using it.\n6.  After filling up the table, return `dp[amount]` if it's not `float('inf')`, which represents the fewest number of coins that make up the target amount. Otherwise, return `-1` to indicate that it's not possible to make up the amount with the given coins.\n\n**Time Complexity Analysis**\n---------------------------\n\nThe time complexity of the algorithm is O(amount \\* len(coins)), where `amount` is the target amount and `len(coins)` is the number of coin denominations.\n\nHere's a breakdown of the time complexity:\n\n*   The outer loop iterates over each coin denomination, which takes O(len(coins)) time.\n*   The inner loop iterates over each amount from the coin denomination to the target amount, which takes O(amount) time.\n*   The update operation inside the inner loop takes constant time O(1).\n*   Therefore, the overall time complexity is O(amount \\* len(coins)).\n\n**Space Complexity Analysis**\n---------------------------\n\nThe space complexity of the algorithm is O(amount), where `amount` is the target amount.\n\nHere's a breakdown of the space complexity:\n\n*   The table `dp` of size `amount + 1` takes O(amount) space.\n*   The input arrays `coins` and `amount` take O(len(coins)) and O(1) space, respectively.\n*   Therefore, the overall space complexity is O(amount), which dominates the space complexity.\n\n**Step-by-Step Approach Explanation**\n--------------------------------------\n\nHere's a step-by-step explanation of the algorithm:\n\n1.  **Initialization**: Create a table `dp` of size `amount + 1` and initialize it with `float('inf')`.\n2.  **Base Case**: Set `dp[0] = 0`, which represents the base case where 0 coins are needed to make up 0 amount.\n3.  **Coin Iteration**: Iterate over each coin denomination `coin`.\n4.  **Amount Iteration**: For each coin, iterate over each amount `x` from `coin` to `amount`.\n5.  **Update**: Update the table `dp[x]` with the minimum number of coins between the current value and `dp[x - coin] + 1`.\n6.  **Result**: Return `dp[amount]` if it's not `float('inf')`, which represents the fewest number of coins that make up the target amount. Otherwise, return `-1` to indicate that it's not possible to make up the amount with the given coins.\n\nBy following these steps, the algorithm efficiently solves the Coin Change problem using dynamic programming.",
  "difficulty": "Medium",
  "category": "Dynamic Programming",
  "companies": ""
}