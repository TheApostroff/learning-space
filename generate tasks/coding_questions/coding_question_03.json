{
  "name": "Longest Increasing Subsequence",
  "question": "**Longest Increasing Subsequence**\n=====================================\n\n### Problem Description\n\nGiven an integer array `nums`, return the length of the longest increasing subsequence.\n\nA subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\n### Input and Output Format\n\n*   **Input:** `int[] nums` - The input array of integers.\n*   **Output:** `int` - The length of the longest increasing subsequence.\n\n### Constraints\n\n*   `0 <= nums.length <= 10^4`\n*   `-10^9 <= nums[i] <= 10^9`\n\n### Examples\n\n#### Example 1\n\n*   **Input:** `nums = [10,9,2,5,3,7,101,18]`\n*   **Output:** `4`\n*   **Explanation:** The longest increasing subsequence is `[2,3,7,101]`, therefore the length is `4`.\n\n#### Example 2\n\n*   **Input:** `nums = [0,1,0,3,2,3]`\n*   **Output:** `4`\n*   **Explanation:** The longest increasing subsequence is `[0,1,2,3]`, therefore the length is `4`.\n\n#### Example 3\n\n*   **Input:** `nums = [7,7,7,7,7]`\n*   **Output:** `1`\n*   **Explanation:** The longest increasing subsequence is `[7]`, therefore the length is `1`.\n\n### Function Signature/Initial Code Structure\n\n```python\nclass Solution:\n    def lengthOfLIS(self, nums: list[int]) -> int:\n        # Your solution here\n        pass\n```\n\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        // Your solution here\n        return 0;\n    }\n}\n```\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        // Your solution here\n        return 0;\n    }\n};\n```",
  "correct_answer": "**Longest Increasing Subsequence (LIS) LeetCode Problem Solution**\n\n### Problem Statement\n\nGiven an integer array `nums`, return the length of the longest increasing subsequence.\n\n### Complete Working Code Solution\n\n```python\ndef lengthOfLIS(nums):\n    \"\"\"\n    Returns the length of the longest increasing subsequence in the given array.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The length of the longest increasing subsequence.\n    \"\"\"\n    if not nums:\n        return 0\n\n    # Initialize dp array with all 1s, as the minimum length of a subsequence is 1\n    dp = [1] * len(nums)\n\n    # Compute the length of the longest increasing subsequence ending at each position\n    for i in range(1, len(nums)):\n        for j in range(i):\n            # If the current element is greater than the previous one, update dp[i] if necessary\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # Return the maximum length found\n    return max(dp)\n\n\n# Example usage:\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # Output: 4\n```\n\n### Algorithm Explanation\n\nThe algorithm used to solve the Longest Increasing Subsequence problem is dynamic programming. The idea is to maintain an array `dp` where `dp[i]` represents the length of the longest increasing subsequence ending at index `i`.\n\nThe algorithm iterates through the input array, and for each element, it checks all previous elements. If the current element is greater than a previous one, it updates `dp[i]` with the maximum length found so far.\n\n### Time Complexity Analysis\n\nThe time complexity of the algorithm is **O(n^2)**, where `n` is the length of the input array. This is because the algorithm uses two nested loops to iterate through the array.\n\n### Space Complexity Analysis\n\nThe space complexity of the algorithm is **O(n)**, where `n` is the length of the input array. This is because the algorithm uses an additional array `dp` of the same length as the input array to store the lengths of the longest increasing subsequences.\n\n### Step-by-Step Approach Explanation\n\n1.  **Initialize dp array**: Create an array `dp` of the same length as the input array, and initialize all elements to 1. This is because the minimum length of a subsequence is 1.\n2.  **Iterate through the array**: Use two nested loops to iterate through the input array. The outer loop iterates over each element, and the inner loop iterates over all previous elements.\n3.  **Update dp array**: If the current element is greater than a previous one, update `dp[i]` with the maximum length found so far.\n4.  **Return the maximum length**: After iterating through the entire array, return the maximum length found in the `dp` array.\n\nThis solution is the most efficient and commonly accepted solution for the Longest Increasing Subsequence problem, with a time complexity of O(n^2) and a space complexity of O(n).",
  "difficulty": "Medium",
  "category": "Dynamic Programming",
  "companies": ""
}