{
  "name": "Climbing Stairs",
  "question": "**Climbing Stairs**\n====================\n\n### Problem Description\n\nYou are climbing a stair case. It takes `n` steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n### Input and Output Format\n\n* **Input:** `int n` - The number of steps in the staircase.\n* **Output:** `int` - The number of distinct ways to climb to the top.\n\n### Constraints\n\n* `1 <= n <= 45`\n\n### Examples\n\n* **Example 1:**\n  * Input: `n = 2`\n  * Output: `2`\n  * Explanation: There are two ways to climb to the top.\n    1. 1 step + 1 step\n    2. 2 steps\n* **Example 2:**\n  * Input: `n = 3`\n  * Output: `3`\n  * Explanation: There are three ways to climb to the top.\n    1. 1 step + 1 step + 1 step\n    2. 1 step + 2 steps\n    3. 2 steps + 1 step\n\n### Solution Structure\n\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        # Your solution here\n        pass\n```\n\nYour task is to complete the `climbStairs` method to calculate the number of distinct ways to climb `n` stairs.",
  "correct_answer": "**Climbing Stairs LeetCode Problem Solution**\n\nThe Climbing Stairs problem is a classic dynamic programming problem. Here's the most efficient and commonly accepted solution:\n\n### Problem Statement\n\nYou are climbing a staircase. It takes `n` steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n### Complete Working Code Solution\n\n```python\ndef climbStairs(n: int) -> int:\n    \"\"\"\n    This function calculates the number of distinct ways to climb a staircase with n steps.\n    \n    :param n: The number of steps in the staircase.\n    :return: The number of distinct ways to climb the staircase.\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    # Initialize an array to store the number of ways to climb i steps\n    ways = [0] * (n + 1)\n    \n    # Base cases\n    ways[1] = 1\n    ways[2] = 2\n    \n    # Calculate the number of ways to climb i steps\n    for i in range(3, n + 1):\n        ways[i] = ways[i - 1] + ways[i - 2]\n    \n    return ways[n]\n\n# Optimized solution with constant space complexity\ndef climbStairsOptimized(n: int) -> int:\n    \"\"\"\n    This function calculates the number of distinct ways to climb a staircase with n steps.\n    \n    :param n: The number of steps in the staircase.\n    :return: The number of distinct ways to climb the staircase.\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    # Initialize variables to store the number of ways to climb the last two steps\n    a, b = 1, 2\n    \n    # Calculate the number of ways to climb i steps\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    \n    return b\n```\n\n### Algorithm Explanation\n\nThe algorithm uses dynamic programming to calculate the number of distinct ways to climb the staircase. The idea is to build up a solution from smaller sub-problems. In this case, the number of ways to climb `i` steps depends on the number of ways to climb `i - 1` steps and `i - 2` steps.\n\n### Time Complexity Analysis\n\nThe time complexity of the algorithm is **O(n)**, where `n` is the number of steps in the staircase. This is because the algorithm needs to iterate from `3` to `n` to calculate the number of ways to climb each step.\n\n### Space Complexity Analysis\n\nThe space complexity of the original algorithm is **O(n)**, where `n` is the number of steps in the staircase. This is because the algorithm needs to store an array of size `n + 1` to store the number of ways to climb each step.\n\nHowever, the optimized solution has a space complexity of **O(1)**, which means it uses constant space. This is because the algorithm only needs to store the number of ways to climb the last two steps, which can be done using two variables.\n\n### Step-by-Step Approach Explanation\n\n1. **Base cases**: If `n` is less than or equal to `2`, return `n`. This is because there is only one way to climb `1` step and two ways to climb `2` steps.\n2. **Initialize variables**: Initialize an array `ways` of size `n + 1` to store the number of ways to climb each step. Alternatively, initialize two variables `a` and `b` to store the number of ways to climb the last two steps.\n3. **Calculate the number of ways to climb each step**: Iterate from `3` to `n` and calculate the number of ways to climb each step. For each step `i`, the number of ways to climb `i` steps is the sum of the number of ways to climb `i - 1` steps and `i - 2` steps.\n4. **Return the result**: Return the number of ways to climb `n` steps, which is stored in `ways[n]` or `b`.\n\nExample use cases:\n\n* `climbStairs(4)` returns `5`, because there are five distinct ways to climb a staircase with `4` steps: `[1, 1, 1, 1]`, `[1, 1, 2]`, `[1, 2, 1]`, `[2, 1, 1]`, and `[2, 2]`.\n* `climbStairsOptimized(4)` returns `5`, which is the same result as the original algorithm.",
  "difficulty": "Easy",
  "category": "Dynamic Programming",
  "companies": ""
}